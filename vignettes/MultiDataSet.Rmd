---
title: "Working with MultiDataSet"
subtitle: "Carlos Ruiz, Carles Hernández, Juan R. González"
author: |
  | Center for Research in Environmental Epidemiology (CREAL), Barcelona, Spain
  | Bioinformatics Research Group in Epidemiolgy             
  | (<http://www.creal.cat/brge.htm>)
date: "`r Sys.Date()`"
package: "`r pkg_ver('MEAL')`"
output: 
  BiocStyle::html_document:
    number_sections: true
    toc: yes
    fig_caption: yes
    fig_height: 3
    fig_width: 4
vignette: >
  %\VignetteIndexEntry{Introduction to MEAL}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---
# MultiDataSet design
`MultiDataSet` is a new class implemented `r Rpackage("MEAL")` designed to manage different omics datasets corresponding to the same experiment. It is based in Bioconductor framework, so it works with S4 classes derived from eSet. The following data is extracted from each eSet-derived object that is added to a `MultiDataSet`:

* The matrix or matrices of data
* The phenotypic data
* The annotation

There are two important features that should be considered when working with `MultiDataSet`:

* Complete data: `MultiDataSet` only contains the samples that are present in all the sets.
* Independent phenotypes: the phenotypic data is stored independently for each set. This allow to store variables with the same name but different values in different sets (e.g. technical variables).

In the code below, the libraries needed in this tutorial will be loaded:

```{r Load libraries, message=FALSE}
library(MEAL)
library(MEALData)
library(minfiData)
``` 

# Create a new MultiDataSet

`MultiDataSet`s should be created prior to adding any eSet object. They are generated using the standard R function:

```{r New Multi}
multi <- new("MultiDataSet")
``` 

The fuction `names` allows to recover the names of sets included in the `MultiDataSet`. Right now, the object is empty so there are no names:

```{r Names empty Multi}
names(multi)
``` 

# Add a set

`r Rpackage("MEAL")` includes three functions to include three specific objects: `ExpressionSet`, `SnpSet` and `MethylationSet`. Let's start by the `ExpressionSet`.

## Adding an ExpressionSet

`ExpressionSet` is the Bioconductor class designed to store a the data of an expression microarray experiment. `r Rpackage("MEALData")` includes an `ExpressionSet` called eset:

```{r eset}
data(eset)
eset
``` 

The function that adds an `ExpressionSet` to a `MultiDataSet` is `add.genexp`. It has three arguments: the `MultiDataSet` where the `ExpressionSet` will be added (object), the `ExpressionSet` to be added (gexpSet) and a boolean to enable or disable the warnings (warning). If we try to directly add eset to multi:

```{r add eset 1, error = TRUE}
add.genexp(multi, eset)
``` 

The function returns an error. In order to be added to the `MultiDataSet`, `ExpressionSet` needs to meet a requirement: its annotation should contain the columns chromosome, start and end. This constraint ensures that the objects will contain all the features needed in the integration analyses. 

Nonetheless, our eset already contains this data. Let's add a new column called chromosome and try again:

```{r add eset 2}
fData(eset)$chromosome <- fData(eset)$chr
multi2 <- add.genexp(multi, eset)
names(multi)
names(multi2)
``` 

There are two things that should be noticed. First, `add.genexp` **does not modify** the `MultiDataSet` passed in the `object` argument. Consequently, the names of multi are still NULL. This property is common of all the functions used to add sets to the `MultiDataSet`. `add.genexp` adds the `ExpressionSet` data to the slot _expression_. This should be kept in mind when retrieving the data. 

## Adding a SnpSet

The function `add.snps` adds a `SnpSet` to the `MultiDataSet`. It is very similar to `add.genexp`, the difference is the second argument, which is snpSet instead of gexpSet. Clearly, snpSet should be a `SnpSet`.

In `r Rpackage("MEALData")`, we have included a list with the genotypes and the annotation:

```{r snps}
data(snps)
names(snps)
snps$genotypes[1:5, 1:5]
head(snps$map)
``` 

The matrix of genotypes represent the status of the SNP (0 for homozygote for allele 1, 1 for heterozygotes and 2 for homozygotes for the allele 2). With this data, we can create a SnpSet:

```{r Create SnpSet}
SnpSet <- new("SnpSet", call = snps$genotypes)
fData(SnpSet) <- snps$map
SnpSet
``` 

Now, we can add SnpSet to multi:

```{r Add SnpSet}
multi2 <- add.snps(multi, SnpSet)
names(multi)
names(multi2)
``` 

As it happened with `add.genexp`, the original object remains unchanged. SNP data is added to the slot _snps_.

## Adding a MethylationSet

The function `add.methy` adds a `MethylationSet` to the `MultiDataSet`. Again, the only difference with  `add.genexp` is in the second argument. In `add.methy` the second argument is called methySet and it should be a `MethylationSet`.

`MethylationSet` is a new class introduced in `r Rpackage("MEAL")` which can be considered the equivalent of the `ExpressionSet` for methylation. In `r Rpackage("MEALData")`, there is no a `MethylationSet`, but there is a matrix of beta values (the methylation values) and a data.frame with the phenotypic variables. With this data, we can easily create a `MethylationSet`:

```{r create methy}
data(betavals)
betavals[1:5, 1:5]
data(pheno)
head(pheno)
methSet <- prepareMethylationSet(matrix = betavals, phenotypes = pheno)
methSet
``` 

`prepareMethylationSet` creates the `MethylationSet` using the matrix of betavalues and the data.frame of phenotypes. If an annotation data.frame is not provided, by default, it loads it from `r Biocannopkg("IlluminaHumanMethylation450kanno.ilmn12.hg19")`. A more exhaustive description of this  and other functions related to `MethylationSet` objects can be found in MEAL vignette. 

Now, we are ready to add the methylation data to multi:

```{r Add MethylationSet}
multi2 <- add.methy(multi, methSet)
names(multi)
names(multi2)
``` 

As before, the multi object remains unchanged. The methylation data is added to the slot _methylation_.

## Adding other eSet-derived classes

Besides the specific functions, there is a general function that can add any eSet-derived objects: `add.set`. `add.set` has four arguments. object and set are equivalent to the first two arguments of the specific functions (the `MultiDataSet` and the object to be added). dataset.name is a character with the name of the slot where the set will be added. Finally, there is also a flag to enable or disable the warnings.

To test this function, we will use the data from `r Rpackage("minfiData")`. `r Rpackage("minfiData")` includes two objects: a `RGChannelSet` (RGsetEx) and a `MethylSet` (MsetEx):

```{r minfi objects}
data(RGsetEx)
RGsetEx
data(MsetEx)
MsetEx
``` 

Both classes are defined in `r Rpackage("minfi")` and are extensions of Bioconductor eSet. In the first example, we will add RGsetEx to the slot _RG_:

```{r Add RGSet}
multi2 <- add.set(multi, RGsetEx, "RG")
names(multi2)
```

There is a new slot called _RG_ that contains the data of the RGsetEx. 

As it can be seen, the specific functions worked in the same way than `add.set`. The reasion is that the specific functions are specific cases of the general function, where the set's class and the slot's name have been fixed. 

# Retrieve a set

Two options have been incorporated to retrieve a set from a `MultiDataSet`. Before starting, let's create a `MultiDataSet` with expression data:

```{r Add eset2}
multi2 <- add.genexp(multi, eset)
names(multi2)
```

multi2 contains now our expression data in the slot _expression_. One option to recover the object is to use the operator `[[`:

```{r get eset}
neweset <- multi2[["expression"]]
neweset
eset
```

With this operation, we get an object like the one we introduced before. The operator `[` has also been overloaded and can be used to get an specific object:

```{r get eset 2}
multi2["expression"]
multi2[1, , drop = TRUE]
```

# Overwrite a set

If we add a set to a existing slot, the old set is overwritten:

```{r overwrite set}
multi2 <- add.set(multi, RGsetEx, "ex")
multi2["ex"]
multi2 <- add.set(multi, MsetEx, "ex")
multi2["ex"]
```

In the example, first we add a RGsetEx to the slot _ex_. Then, we add MsetEx to slot _ex_. RGsetEx is removed from multi2 and it is substituted by MsetEx. The same behavior applies for the specific functions: `add.genexp`, `add.snps` and `add.methy`.

# Keep complete data

The functions used to add new objects to the `MultiDataSet` ensures that only samples present in all the sets are included in the `MultiDataSet`. To this end, each time that a new function is added, both the incoming set and the existing sets are filtered to the common samples. Let's illustrate it with an example. Now we will create a `MultiDataSet` with the `ExpressionSet` and the `SnpSet` created above. First, we will add the `SnpSet`:

```{r}
SnpSet
multi2 <- add.snps(multi, SnpSet)
names(multi2)
```

Now we will add the eset: 

```{r}
eset
multi2 <- add.genexp(multi2, eset)
names(multi2)
```

A warning has raised. SnpSet contained 98 samples and eset 61, so SnpSet has been filtered to the samples also present in eset.

```{r}
multi2["expression"]
multi2["snps"]
length(intersect(sampleNames(eset), sampleNames(SnpSet)))
```

Given that all the samples of eset where also present in SnpSet, eset was not filtered. Now, we will add the `MethylationSet`:

```{r}
methSet
multi2 <- add.methy(multi2, methSet)
names(multi2)
```

Despite that methSet had the same number of samples than the sets present in multi2, the same warning appeared again. Let's check the `MultiDataSet` sets:

```{r}
multi2["expression"]
multi2["snps"]
multi2["methylation"]
length(intersect(sampleNames(eset), sampleNames(methSet)))
```

Now all the objects have 57 samples. This number is equal to the intersection between the sample names of eset and methSet. In the more extreme case, where there will not be any common samples between the sets, an error is returned:

```{r, error = TRUE}
multi2 <- add.set(multi2, RGsetEx, "RG")
```

# Subset a MultiDataSet

The operator `[` allows to subset the `MultiDataSet`. The first parameter selects the sets. Let's try this function with the `MultiDataSet` with methSet, eset and SnpSet.

```{r}
names(multi2)
names(multi2[1:2])
```

In this example, the first two sets are selected (snps and expression). The subset can also be done using names:

```{r}
names(multi2[c("snps", "methylation")])
```

If the subsetting only includes a set, a set is returned. If we want a `MultiDataSet` with only a set, we need to set drop = FALSE:

```{r}
class(multi2["methylation"])
class(multi2["methylation", drop = FALSE])
```

With the second argument we can filter the samples of the `MultiDataSet`. With these parameter we can select some samples of all the sets:

```{r}
multi3 <- multi2[, 1:10]
multi3[["snps"]]
multi3[["expression"]]
multi3[["methylation"]]
```

With this code, all the sets have been filtered to the first ten samples. We can subset at the same time sets and samples:

```{r}
multi3 <- multi2[1:2, 1:10]
names(multi3)
multi3[["snps"]]
multi3[["expression"]]
```

We can also select a set and subset the samples at the same time:

```{r}
multi2["methylation", 1:10]
```